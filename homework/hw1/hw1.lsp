; problems 1-3 assume that the input parameter TREE is a VALID ordered tree,
; defined as the following from the assignment:
; -----------------------------------------------------------------------------
; An ordered tree is either a number n or a list (L m R), where:
; -- L and R are ordered trees
; -- m is a number
; -- all numbers appearing in L are less than m
; -- all numbers appearing in R are greater than m


; input: N (number to search for), TREE (ordered tree)
; output: T if N is found in TREE, else T
; -----------------------------------------------------------------------------
; base case: if TREE is just a number, check if equal to N and return result
; case 1: if mid element of TREE is less than N, recurse on left child
; case 2: if mid element of TREE is greater than N, recurse on right child
; else: TREE doesn't contain N, return NIL (doesn't need to be there if it is
; a valid ordered tree, but the case should be included for good style)
(defun TREE-CONTAINS (N TREE)
	(cond 
		((numberp TREE) (= N TREE))
		((< N (cadr TREE)) (TREE-CONTAINS N (car TREE)))
		((> N (cadr TREE)) (TREE-CONTAINS N (caddr TREE)))
		(t nil)
	)
)

; input: TREE (ordered tree)
; output: max element from TREE
; -----------------------------------------------------------------------------
; base case: no right child, return current element
; else: recurse on right child
(defun TREE-MAX (TREE)
	(cond
		((numberp TREE) TREE)
		(t (TREE-MAX (caddr TREE)))
	)
)

; input: TREE (ordered tree)
; output: sorted list of elements in TREE
; -----------------------------------------------------------------------------
; base case: if TREE is a number, make it a list
; else: append list generated by left child to current element to list 
; generated by right child and return
(defun TREE-ORDER (TREE)
	(cond
		((numberp TREE) (list TREE))
		(t (append
			(TREE-ORDER (car TREE))
			(TREE-ORDER (cadr TREE))
			(TREE-ORDER (caddr TREE))
		))
	)
)

; input: L (list), START (starting index), LEN (length of sublist)
; output: sublist of L starting at index START with length LEN
; -----------------------------------------------------------------------------
; base case: START beyond list length or LEN less than 1, return NIL
; case 1: move right until at index START
; case 2: append to result until base case
(defun SUB-LIST (L START LEN)
	(cond
		((< (- (length L) 1) START) nil) ; check valid START
		((< LEN 1) nil) ; check valid LEN
		((> START 0) (SUB-LIST (cdr L) (- START 1) LEN))
		(t (append
			(list (car L))
			(SUB-LIST (cdr L) 0 (- LEN 1)) ; append one by one
		))
	)
)

; input: L (list)
; output: list of two lists L1 and L2 where the two lists have a difference in
; length of less than 2 and L2 is the longer list in the case of a tie
; -----------------------------------------------------------------------------
; procedure: find the length of L1, call SUB-LIST function to create the two
; sublists (L1 from index 0 to L1LEN-1, L2 from index L1LEN to end)
(defun SPLIT-LIST (L)
	(let 
		((L1LEN
			(cond
				((evenp (length L)) (/ (length L) 2))
				(t (/ (- (length L) 1) 2))
			)
		))
		(append
			(list (SUB-LIST L 0 L1LEN))
			(list (SUB-LIST L L1LEN (- (length L) L1LEN)))
		)
	)
)

; input: TREE (binary tree, each node has 0 or 2 children)
; output: length of path in TREE from root to farthest leaf node
; -----------------------------------------------------------------------------
; procedure: recursively find the maximum lengths of the left subtree and right
; subtree, return the greater value
; base case: if leaf node, return 0
; else: recurse and add 1 to current height
(defun BTREE-HEIGHT (TREE)
	(cond
		((not (listp TREE)) 0)
		(t (let
			(
				(LEFT (BTREE-HEIGHT (car TREE)))
				(RIGHT (BTREE-HEIGHT (cadr TREE)))
			)
			(cond
				((> LEFT RIGHT) (+ LEFT 1))
				(t (+ RIGHT 1))
			)
		))
	)
)

; input: LEAVES (non empty list of atoms)
; output: binary tree such that the tree leaves are the elements of LEAVES and
; for any non-leaf node in the tree, the number of leaves in its right branch
; minus the of leaves in its left branch is less than 2
; -----------------------------------------------------------------------------
; base case: list only has 1 element, return it
; else: recursively call SPLIT-LIST to create internal nodes and combine them
(defun LIST2BTREE (LEAVES)
	(cond
		((= (length LEAVES) 1) (car LEAVES))
		(t (let ((SPLITTED (SPLIT-LIST LEAVES)))
			(append
				(list (LIST2BTREE (car SPLITTED)))
				(list (LIST2BTREE (cadr SPLITTED)))
			)
		))
	)
)

; input: TREE (binary tree)
; output: returns list of in-order traversal of TREE
; -----------------------------------------------------------------------------
; base case: if TREE is a number, make it a list
; else: recursively append list generated by left node to list generated by
; right node and return
; essentially the exact same logic as TREE-ORDER, but nodes are atoms instead
; of numbers
(defun BTREE2LIST (TREE)
	(cond
		((not (listp TREE)) (list TREE))
		(t (append
			(BTREE2LIST (car TREE))
			(BTREE2LIST (cadr TREE))
		))
	)
)

; input: 2 lisp expressions, E1 and E2
; output: returns TRUE if expressions are equal, else NIL
; -----------------------------------------------------------------------------
; base case: end of list, return TRUE
; case 1: if both numbers, check if they're equal
; case 2: if list lengths are different, return NIL (structured under list 
; checks because checking length on an atom will raise type error)
; recursive: if both lists, check if curr element is the same and then move on
; to rest of expression
(defun IS-SAME (E1 E2)
	(cond
		((and (null E1) (null E2)) t)
		((and (numberp E1) (numberp E2)) (= E1 E2))
		((and (listp E1) (listp E2))
			(cond
				((not (= (length E1) (length E2))) nil)
				(t (and (IS-SAME (car E1) (car E2)) (IS-SAME (cdr E1) (cdr E2))))
			)
		)
		(t nil) ; one is an atom, one is a list
	)
)
